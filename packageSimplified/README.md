# C语言面向对象之封装 #

面向对象的思想可以大大简化编程过程中的困难，因此学会C语言面向对象思想显得尤其重要，如果能够写出优美的程序框架甚至类似于Lua语言的面向对象升级模块，那可谓十分厉害了。

## 类的属性 ##

类的封装，不得不提到属性和行为，而属性看上去则较为简单，因此我们先来讨论封装属性。

C语言提供了结构体这一数据结构，我们可以很方便地使用结构体来实现对属性地封装。

## 类的行为 ##

再谈到类的行为，我们可以通过函数指针的形式对其进行封装，另外，为了将其和属性区分开来，我另外创建了一个结构体，在这个结构体中包含着所有的类行为，称为 `行为表` 。值得改进的一点是，在这个示例中，我想到的方法是每创建一个对象就创建若干个函数指针，这样是对资源的极大浪费，后续可以对其进行改进。

## 私有化成员属性 ##

私有化不得不让我们想到将结构体仅声明在源文件中，这样该源文件外的其它文件就无法对私有化的属性和行为进行直接访问了。由此引出了另外一个问题，我们怎么将一个类中的事物清晰地分成两部分而使用时不太复杂呢？此时又能通过C语言的数据结构 `联合体类型` 来解决了，联合体类型一次只能访问其中的一个成员，因此可以用来隐藏私有部分，具体的做法如下：

    typedef struct Object_Internal{
        union{
            Object public;
            void *intro;
        };
        uint8_t age;
        Object_Internal_Method_Table *ivptr;
    }Object_Internal;

其中包含了一个联合体类型的变量，它有两个成员，分别是 `public` 和 `intro`，其中public是类的公有部分，intro是占位符，它不起实际作用，当我们访问私有部分时，为了“专注于”私有部分，应该忽略联合体中的public成员，而当访问公有部分时，也应当忽略联合体中的intro成员。

## 注意点 ##

### new_Object ###

示例中的 `new_Object()` “构造函数”为方便起见设计成了返回对象指针的方式，简化了返回对象后需要数据拷贝的过程。

### delete_Object ###

示例的 `delete_Object()` “析构函数”由于本人能力有限，无法实现通过 `delete_Object(this)` 的方式进行析构，只能将其设计成 `obj = delete_Object(obj)` 的形式。

## 优化 ##

2023.01.--

将构造对象时需要给每一个对象申请行为表改为行为表申请在类中，减少资源的浪费。

2023.02.12

1. 优化行为表设计。因为在“类”的源文件中已经有了行为表指针，我们不需要在每个对象中添加一个行为表指针用来调用对应的函数，只需让外界能够通过已经存在的这个指针对行为表进行访问即可。基于以上原因，我们可以增加一个API函数，它会返回一个const的指针，外界通过这个API函数实现以前的功能，同时，为了开发人员的可读性，应通过特定的、标准化的设计，使其呈现出类似自然语言的效果。以下给出其中一种解决方案：

    const Object_Method_Table *Object_vptr(void)
    {
        return (const Object_Method_Table*)(&vptr);
    }

2. 优化对象生成方式。对象通过malloc方式申请存在着很多问题，如：内存碎片化、申请不成功等等，非常不利于应用于嵌入式开发，因此需要重新进行设计。首先，我们在外界可以通过指针方式创建对象，但这实际上仅仅是声明了一个对象，还没有对其进行实例化，而实例化又得在另一个地方创建对象，这就有很多种方法了，不过都不太符合我们的要求，因此选择直接创建对象。创建完对象之后，我们需要对它进行初始化，原来我们写了一个新建对象的API函数，我们可以通过调用该API函数完成初始化，但是，在这里，我们使用的是C语言，同时，我们是直接创建了对象的，因此调用函数进行初始化的步骤就显得有点画蛇添足的意味了，所以我们可以在定义它的时候直接完成初始化。另外提一点，结构体在定义时就初始化的条件是，编译器允许这样做，如果编译器不允许，可以选择通过API函数进行初始化操作。

3. 优化对象生成方式后导致的私有成员无法初始化的问题。
